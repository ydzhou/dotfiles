autocmd! bufwritepost .vimrc source %

call plug#begin()
" Bundles
Plug 'ctrlpvim/ctrlp.vim'
Plug 'ryanoasis/vim-devicons'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'tomtom/tcomment_vim'
Plug 'jiangmiao/auto-pairs'
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'prabirshrestha/asyncomplete-buffer.vim'
Plug 'lambdalisue/fern.vim'
Plug 'lambdalisue/fern-hijack.vim'
Plug 'lambdalisue/fern-renderer-nerdfont.vim'
Plug 'lambdalisue/nerdfont.vim'
Plug 'justinmk/vim-dirvish'
" Colorscheme
Plug 'ydzhou/monocolor.vim'
Plug 'morhetz/gruvbox'
Plug 'arcticicestudio/nord-vim'
Plug 'rakr/vim-one'
Plug 'vim-scripts/pyte'
Plug 'NLKNguyen/papercolor-theme'
call plug#end()

set nocompatible
set mouse=a
set backspace=indent,eol,start
set gcr=a:blinkon0
set autoread
set noeb vb t_vb=
if has('autocmd')
	autocmd GUIEnter * set visualbell t_vb=
endif
set encoding=UTF-8
" Show completion candidates for vim commands
set wildmenu
set nofoldenable

set wrap lbr
set display=lastline
set tabstop=4 shiftwidth=4 softtabstop=4 expandtab
set cindent autoindent
set clipboard+=unnamed

" set ruler
set laststatus=2
set statusline=%03l,%03v\ %p%%\ %<%=%F%m%r%h%w

syntax on
if has("gui_running")
	set number
	" set guifont=AnonymousProMinus:h16
    " set guifont=Menlo-Regular:h16
    " set guifont=IosevkaNerdFontComplete-:h15
    set guifont=MesloLGMNerdFontComplete-Regular:h15
	set linespace=2
    set guioptions-=m
	set guioptions-=r
	set guioptions-=T
	set guioptions-=e
	set guioptions-=L
	set lines=40
	set columns=120
	" set background=dark
	colorscheme monocolor
    autocmd InsertEnter,InsertLeave * set cul!
else
	set guioptions-=e
	set t_Co=256
	set number
	" set background=dark
	colorscheme monocolor
endif

set incsearch ignorecase smartcase

""Backup
set noswapfile
set backupdir=~/.vim/backup

let mapleader=","
map ; <C-d>
map ' <C-u>
map <silent> <Leader>, <C-o>
map <silent> <Leader>. <C-i>
"" standard keys for wrapped lines
set whichwrap+=<,>,[,]
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
"" easier moving of code block
vnoremap < <gv
vnoremap > >gv
" Paste from 0 register to avoid cannot paste after deletion
nnoremap d "_d
xnoremap d "_d
nnoremap x "_x
xnoremap x "_x
" Cancel search highlights
nnoremap <C-h> :nohl<CR>

" Automatically open, but do not go to (if there are errors) the quickfix /
" location list window, or close it when is has become empty.
"
" Note: Must allow nesting of autocmds to enable any customizations for quickfix
" buffers.
" Note: Normally, :cwindow jumps to the quickfix window if the command opens it
" (but not if it's already open). However, as part of the autocmd, this doesn't
" seem to happen.
"autocmd QuickFixCmdPost [^l]* nested cwindow
"autocmd QuickFixCmdPost    l* nested lwindow
autocmd WinEnter * if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"|q|endif

""""""""""""""""""""""""""
"" LANGUAGES CUSTOMIZATION
filetype on
filetype plugin on
filetype indent on

autocmd BufNewFile,BufReadPost *.md set filetype=markdown

""""""""""""""""""""""""""
"" PLUGINS

" CtrlP
nnoremap <Leader>// :CtrlPLine<CR>
let g:ctrlp_map = '<Leader>/'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_custom_ignore = {
            \ 'dir': '\.git$\|\.hg$\|\.svn$\|Library$\|Applications$\|Movies$\|Pictures$\|Music$\|tmp$',
            \ 'file': '\.zip$\|\.so$\|\.o$\|\.obj$\|\.class$\|\.DS_Store$'
            \}
let g:ctrlp_match_window = 'bottom,order:btt,min:5,max:30,results:30'
" if executable('fd')
"     let g:ctrlp_user_command = 'fd --type f --color never "" %s'
" endif
" if executable('rg')
"     set grepprg=rg\ --color=never
"     let g:ctrlp_user_command = 'rg %s --files --color=never --glob "" --ignore-file ~/dotfiles/ignore'
" let g:webdevicons_enable_ctrlp = 1
let g:ctrlp_by_filename = 0
let g:ctrlp_use_caching = 0
let g:ctrlp_mruf_max = 0
let g:ctrlp_max_files = 0
let g:ctrlp_user_command_async = 0

" FZF
map <silent> <Leader>f :Files<CR>
map <silent> <Leader>fl :Lines<CR>
let $FZF_DEFAULT_COMMAND = "fd --type file"
let g:fzf_layout = { 'down':  '40%'}
let g:fzf_preview_window = []

" Fern
map <silent> <C-n> :Fern . -drawer -toggle -width=40<CR>

" Disable netrw.
let g:loaded_netrw  = 1
let g:loaded_netrwPlugin = 1
let g:loaded_netrwSettings = 1
let g:loaded_netrwFileHandlers = 1
let g:fern#renderer = "nerdfont"
let g:fern#disable_default_mappings = 1
let g:fern#disable_drawer_tabpage_isolation = 0
" let g:fern#drawer_width = 40
function! FernInit() abort
  nmap <buffer><expr>
        \ <Plug>(fern-my-open-expand-collapse)
        \ fern#smart#leaf(
        \   "\<Plug>(fern-action-open:select)",
        \   "\<Plug>(fern-action-expand)",
        \   "\<Plug>(fern-action-collapse)",
        \ )
  nmap <buffer> <CR> <Plug>(fern-my-open-expand-collapse)
  nmap <buffer> <2-LeftMouse> <Plug>(fern-my-open-expand-collapse)
  nmap <buffer> o <Plug>(fern-action-open)
  nmap <buffer> t <Plug>(fern-action-open:tabedit)
  nmap <buffer> n <Plug>(fern-action-new-path)
  nmap <buffer> N <Plug>(fern-action-new-file)
  nmap <buffer> y <Plug>(fern-action-copy)
  nmap <buffer> p <Plug>(fern-action-paste)
  nmap <buffer> m <Plug>(fern-action-move)
  nmap <buffer> D <Plug>(fern-action-remove)
  nmap <buffer> r <Plug>(fern-action-rename)
  nmap <buffer> h <Plug>(fern-action-hidden-toggle)j
  nmap <buffer> R <Plug>(fern-action-reload)
  nmap <buffer> k <Plug>(fern-action-mark-toggle)j
  nmap <buffer><nowait> > <Plug>(fern-action-open-or-enter)
  nmap <buffer><nowait> < <Plug>(fern-action-leave)
endfunction
augroup FernGroup
  autocmd!
  autocmd FileType fern call FernInit()
augroup END

" TComment
"let g:tcommentOptions = {'whitespace' : 'no'}
map <silent> <Leader>c :TComment<CR>

" LSP
map <silent> <Leader>d :LspDefinition<CR>
map <silent> <Leader>i :LspImplementation<CR>
map <silent> <Leader>h :LspHover<CR>
let g:lsp_diagnostics_echo_cursor = 1
" Async Completion
" Auto popup
let g:asyncomplete_auto_popup = 1
" Minimum char to autocomplete
let g:asyncomplete_min_chars = 0

autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
" Preview window
set completeopt=menuone,noinsert,noselect,preview

call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
    \ 'name': 'buffer',
    \ 'allowlist': ['*'],
    \ 'blocklist': ['markdown'],
    \ 'completor': function('asyncomplete#sources#buffer#completor'),
    \ 'config': {
    \    'max_buffer_size': 5000000,
    \  },
    \ }))
