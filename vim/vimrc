autocmd! bufwritepost .vimrc source %

call plug#begin()
" Bundles
" Plug 'kien/ctrlp.vim'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'tomtom/tcomment_vim'
Plug 'jiangmiao/auto-pairs'
Plug 'ydzhou/monocolor.vim'
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'prabirshrestha/asyncomplete-buffer.vim'
Plug 'lambdalisue/fern.vim'
Plug 'morhetz/gruvbox'
call plug#end()

set nocompatible
set mouse=a
set backspace=indent,eol,start
set gcr=a:blinkon0
set autoread
set noeb vb t_vb=
if has('autocmd')
	autocmd GUIEnter * set visualbell t_vb=
endif

set wrap lbr
set display=lastline
set tabstop=4 shiftwidth=4 softtabstop=4 expandtab
set cindent autoindent
set clipboard+=unnamed

"set ruler
set laststatus=2
set statusline=[%03l,%03v][%p%%]\ %=%F%m%r%h%w%<\ [%{&ff}:%{&fenc!=''?&fenc:&enc}]\ [%Y]

syntax on
if has("gui_running")
	set number
	" set guifont=AnonymousProMinus:h16
    set guifont=Menlo-Regular:h16
	set linespace=4
    set guioptions-=m
	set guioptions-=r
	set guioptions-=T
	set guioptions-=e
	set guioptions-=L
	set lines=40
	set columns=120
	" set background=dark
	" colorscheme monocolor
	colorscheme gruvbox
    autocmd InsertEnter,InsertLeave * set cul!
else
	set guioptions-=e
	set t_Co=256
	set number
	" set background=dark
	colorscheme monocolor
endif

set incsearch hlsearch ignorecase smartcase

""Backup
set noswapfile
set backupdir=~/.vim/backup

let mapleader=","
map ; <C-d>
map ' <C-u>
map <silent> <Leader>, <C-o>
map <silent> <Leader>. <C-i>
"" standard keys for wrapped lines
set whichwrap+=<,>,[,]
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
"" easier moving of code block
vnoremap < <gv
vnoremap > >gv

" Automatically open, but do not go to (if there are errors) the quickfix /
" location list window, or close it when is has become empty.
"
" Note: Must allow nesting of autocmds to enable any customizations for quickfix
" buffers.
" Note: Normally, :cwindow jumps to the quickfix window if the command opens it
" (but not if it's already open). However, as part of the autocmd, this doesn't
" seem to happen.
"autocmd QuickFixCmdPost [^l]* nested cwindow
"autocmd QuickFixCmdPost    l* nested lwindow
autocmd WinEnter * if winnr('$') == 1 && getbufvar(winbufnr(winnr()), "&buftype") == "quickfix"|q|endif

""""""""""""""""""""""""""
"" LANGUAGES CUSTOMIZATION
filetype on
filetype plugin on
filetype indent on

autocmd BufNewFile,BufReadPost *.md set filetype=markdown

""""""""""""""""""""""""""
"" PLUGINS

" CtrlP
" let g:ctrlp_map = '<leader>/'
" let g:ctrlp_working_path_mode = 'ra'
" set wildignore+=*/Movies/*,*Pictures/*,*/Music/*,*/Library/*,*/tmp/*,*.so,*.o,*.a,*.obj,*.swp,*.zip,*.pyc,*.pyo,*.class,.DS_Store
" let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$\|\.rvm$'
" let g:ctrlp_max_height=15
" let g:ctrlp_by_filename = 1

" FZF
map <silent> <Leader>f :FZF<CR>

" Fern
map <silent> <C-n> :Fern . -drawer -reveal=% -toggle -width=35<CR><C-w>=

" Disable netrw.
let g:loaded_netrw  = 1
let g:loaded_netrwPlugin = 1
let g:loaded_netrwSettings = 1
let g:loaded_netrwFileHandlers = 1

augroup my-fern-hijack
  autocmd!
  autocmd BufEnter * ++nested call s:hijack_directory()
augroup END

function! s:hijack_directory() abort
  let path = expand('%:p')
  if !isdirectory(path)
    return
  endif
  bwipeout %
  execute printf('Fern %s', fnameescape(path))
endfunction

let g:fern#disable_default_mappings = 1
function! FernInit() abort
  nmap <buffer><expr>
        \ <Plug>(fern-my-open-expand-collapse)
        \ fern#smart#leaf(
        \   "\<Plug>(fern-action-open:select)",
        \   "\<Plug>(fern-action-expand)",
        \   "\<Plug>(fern-action-collapse)",
        \ )
  nmap <buffer> <CR> <Plug>(fern-my-open-expand-collapse)
  nmap <buffer> <2-LeftMouse> <Plug>(fern-my-open-expand-collapse)
  nmap <buffer> n <Plug>(fern-action-new-path)
  nmap <buffer> d <Plug>(fern-action-remove)
  nmap <buffer> m <Plug>(fern-action-move)
  nmap <buffer> M <Plug>(fern-action-rename)
  nmap <buffer> h <Plug>(fern-action-hidden-toggle)j
  nmap <buffer> R <Plug>(fern-action-reload)
  nmap <buffer> k <Plug>(fern-action-mark-toggle)j
  nmap <buffer><nowait> < <Plug>(fern-action-leave)
  nmap <buffer><nowait> > <Plug>(fern-action-enter)
endfunction
augroup FernGroup
  autocmd!
  autocmd FileType fern call FernInit()
augroup END


" TComment
"let g:tcommentOptions = {'whitespace' : 'no'}
map <silent> <Leader>c :TComment<CR>

" LSP
map <silent> <Leader>d :LspDefinition<CR>
map <silent> <Leader>i :LspImplementation<CR>
map <silent> <Leader>h :LspHover<CR>
let g:lsp_diagnostics_echo_cursor = 1
" Async Completion
let g:asyncomplete_auto_popup = 1
autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
" Preview window
set completeopt=menuone,noinsert,noselect,preview

call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
    \ 'name': 'buffer',
    \ 'allowlist': ['*'],
    \ 'blocklist': ['markdown'],
    \ 'completor': function('asyncomplete#sources#buffer#completor'),
    \ 'config': {
    \    'max_buffer_size': 5000000,
    \  },
    \ }))
